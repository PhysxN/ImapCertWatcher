using FirebirdSql.Data.FirebirdClient;
using ImapCertWatcher.Data;
using ImapCertWatcher.Models;
using ImapCertWatcher.Utils;
using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MimeKit;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Authentication;
using System.Text.RegularExpressions;

namespace ImapCertWatcher.Services
{
    public class ImapWatcher
    {
        private readonly AppSettings _settings;
        private readonly DbHelper _db;
        private readonly string _attachmentsBasePath;
        private readonly string _logDirectory;
        private readonly Action<string> _addToMiniLog;

        private static Regex certNumberRegex = new Regex(@"Сертификат №\s*(?<number>[0-9A-F]+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private static Regex fioRegex = new Regex(@"ФИО:\s*(?<fio>[\p{L}\s\-]+?)(?:\.|\n|$)", RegexOptions.Compiled);
        private static Regex datesRegex = new Regex(@"с\s*(?<ds>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2})\s*по\s*(?<de>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2})", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private static Regex fioRegexAlt1 = new Regex(@"ФИО:\s*(?<fio>[\p{L}\s\-]+)\s*$", RegexOptions.Compiled | RegexOptions.Multiline);
        private static Regex fioRegexAlt2 = new Regex(@"ФИО\s*=\s*(?<fio>[\p{L}\s\-]+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private static Regex datesRegexAlt1 = new Regex(@"с\s*(?<ds>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2}).*?по\s*(?<de>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2})", RegexOptions.Compiled | RegexOptions.Singleline);
        private static Regex datesRegexAlt2 = new Regex(@"Срок действия сертификата:\s*с\s*(?<ds>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2})\s*по\s*(?<de>\d{2}\.\d{2}\.\d{4}\s+\d{2}:\d{2}:\d{2})", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private static Regex revokeDateRegex = new Regex(@"Дата отзыва сертификата:\s*(?<date>\d{2}\.\d{2}\.\d{4})\s*\d{2}:\d{2}:\d{2}", RegexOptions.Compiled | RegexOptions.IgnoreCase);

        public ImapWatcher(AppSettings settings, DbHelper db, Action<string> addToMiniLog = null)
        {
            _settings = settings;
            _db = db;
            _addToMiniLog = addToMiniLog;
            _attachmentsBasePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Certs");
            _logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "LOG");

            // Создаем папку для архивов, если ее нет
            if (!Directory.Exists(_attachmentsBasePath))
                Directory.CreateDirectory(_attachmentsBasePath);

            // Создаем папку для логов, если ее нет
            if (!Directory.Exists(_logDirectory))
                Directory.CreateDirectory(_logDirectory);

            Log("Инициализация ImapWatcher завершена");
        }



        private DateTime? ExtractRevokeDate(string body)
        {
            var match = revokeDateRegex.Match(body);
            if (!match.Success)
                return null;

            if (DateTime.TryParseExact(
                    match.Groups["date"].Value,
                    "dd.MM.yyyy",
                    System.Globalization.CultureInfo.GetCultureInfo("ru-RU"),
                    System.Globalization.DateTimeStyles.None,
                    out DateTime date))
            {
                return date;
            }

            return null;
        }

        public (List<CertEntry> processedEntries, int updatedCount, int addedCount) CheckMail(bool checkAllMessages = false)
        {
            var results = new List<CertEntry>();
            int updatedCount = 0;
            int addedCount = 0;

            // Второй проход — накопитель сообщений с извлечёнными данными сертификатов
            var certificatesToProcess = new List<(CertEntry certData, MimeMessage message, string body, bool hasZip)>();

            // Третий проход — список аннулирований
            var revocationList = new List<(string certNumber, string fio, DateTime? revokeDate, string folderPath)>();

            Log("=== Начало проверки почты ===");

            try
            {
                ValidateMailSettings();
            }
            catch (Exception ex)
            {
                Log($"Ошибка настроек: {ex.Message}");
                return (results, updatedCount, addedCount);
            }

            using (var client = new ImapClient())
            {
                try
                {
                    client.Timeout = 60000;
                    client.ServerCertificateValidationCallback = (s, c, h, e) => true;

                    // Подключение
                    if (_settings.MailUseSsl)
                        client.Connect(_settings.MailHost, _settings.MailPort, MailKit.Security.SecureSocketOptions.SslOnConnect);
                    else
                        client.Connect(_settings.MailHost, _settings.MailPort, MailKit.Security.SecureSocketOptions.StartTlsWhenAvailable);

                    // Аутентификация
                    client.Authenticate(_settings.MailLogin, _settings.MailPassword);

                    // Получаем папку (попробуем рекурсивно искать, если прямой путь не сработал)
                    IMailFolder folder = null;
                    try
                    {
                        folder = GetFolderRecursive(client, _settings.ImapFolder) ?? client.GetFolder(_settings.ImapFolder);
                    }
                    catch
                    {
                        try { folder = client.GetFolder(_settings.ImapFolder); } catch { folder = null; }
                    }

                    if (folder == null)
                    {
                        Log($"Не удалось найти папку '{_settings.ImapFolder}' на сервере.");
                        client.Disconnect(true);
                        return (results, updatedCount, addedCount);
                    }

                    // Открываем в режиме чтения (ReadOnly)
                    folder.Open(FolderAccess.ReadOnly);

                    // Поисковый запрос
                    IList<UniqueId> uids;
                    if (checkAllMessages)
                        uids = folder.Search(SearchQuery.All);
                    else
                    {
                        // По умолчанию только последние 3 дня (если явно не просили все)
                        uids = folder.Search(SearchQuery.DeliveredAfter(DateTime.Now.AddDays(-3)));
                    }

                    Log($"Папка: {folder.FullName}, найдено писем: {uids.Count}");

                    // -----------------------
                    // ПЕРВЫЙ ПРОХОД — Сбор и добавление базовых данных (ФИО, номер, даты)
                    // -----------------------
                    foreach (var uid in uids)
                    {
                        try
                        {
                            var msg = folder.GetMessage(uid);
                            var subject = msg.Subject ?? string.Empty;
                            var body = GetMessageBody(msg);
                            var fromAddress = msg.From.Mailboxes.FirstOrDefault()?.Address ?? string.Empty;

                            Log($"[1-й проход] UID={uid}: {subject}");

                            // Проверка: письмо об аннулировании -> отложим в список аннулирований
                            if (IsRevokedCertificateMessage(subject) || Regex.IsMatch(subject, @"аннулир|прекратил действие", RegexOptions.IgnoreCase))
                            {
                                Log($"Обнаружено письмо об аннулировании (UID={uid})");
                                string certNumber = ExtractCertNumber(subject) ?? ExtractCertNumber(body);
                                string fio = ExtractFio(body);
                                DateTime? revokeDate = ExtractRevokeDate(body);
                                revocationList.Add((certNumber, fio, revokeDate, folder.FullName));
                                continue; // не добавляем в обычный поток сертификатов
                            }

                            // Извлекаем ключевые данные сертификата
                            string fioFound = ExtractFio(body);
                            string certNumberFound = ExtractCertNumber(body);
                            var dates = ExtractDates(body);

                            // Если не удалось извлечь минимум — пропускаем письмо
                            if (string.IsNullOrWhiteSpace(fioFound)
                                || string.IsNullOrWhiteSpace(certNumberFound)
                                || dates.start == DateTime.MinValue
                                || dates.end == DateTime.MinValue)
                            {
                                Log($"[1-й проход] UID={uid} — недостаточно данных, пропускаем");
                                continue;
                            }

                            Log($"[1-й проход] Извлечено: ФИО='{fioFound}', №='{certNumberFound}', {dates.start:dd.MM.yyyy} - {dates.end:dd.MM.yyyy}");

                            bool hasZipAttachment = msg.Attachments.Any(a =>
                                (a.ContentDisposition?.FileName ?? a.ContentType.Name ?? "")
                                .EndsWith(".zip", StringComparison.OrdinalIgnoreCase));

                            // Формируем запись для второго прохода
                            var certData = new CertEntry
                            {
                                MailUid = uid.ToString(),
                                Fio = fioFound,
                                DateStart = dates.start,
                                DateEnd = dates.end,
                                DaysLeft = (int)(dates.end - DateTime.Now).TotalDays,
                                Subject = subject,
                                Received = msg.Date.UtcDateTime,
                                CertNumber = certNumberFound,
                                FromAddress = fromAddress,
                                FolderPath = folder.FullName,
                                MessageDate = msg.Date.UtcDateTime
                            };

                            // Сохраняем/обновляем базовые данные в БД (InsertOrUpdate)
                            try
                            {
                                var (upd, add) = _db.InsertOrUpdate(certData);
                                if (upd) updatedCount++;
                                if (add) addedCount++;
                                Log($"[1-й проход] InsertOrUpdate: FIO={certData.Fio}, Cert={certData.CertNumber}, upd={upd}, add={add}");
                            }
                            catch (Exception ex)
                            {
                                Log($"[1-й проход] Ошибка InsertOrUpdate для {certData.CertNumber}: {ex.Message}");
                            }

                            certificatesToProcess.Add((certData, msg, body, hasZipAttachment));
                        }
                        catch (Exception ex)
                        {
                            Log($"[1-й проход] Ошибка при обработке UID={uid}: {ex.Message}");
                        }
                    }

                    // -----------------------
                    // ВТОРОЙ ПРОХОД — Обработка архивов и дополнительное обновление записей
                    // -----------------------
                    Log($"=== Второй проход: обработка {certificatesToProcess.Count} писем (архивы и обновления) ===");

                    foreach (var (certData, message, body, hasZip) in certificatesToProcess)
                    {
                        try
                        {
                            Log($"[2-й проход] Обработка сертификата {certData.CertNumber} / {certData.Fio}");

                            // Повторная проверка на аннулирование внутри письма (если вдруг)
                            if (IsRevokedCertificateMessage(message.Subject ?? string.Empty) ||
                                Regex.IsMatch(message.Subject ?? string.Empty, @"аннулир|прекратил действие", RegexOptions.IgnoreCase))
                            {
                                Log($"[2-й проход] Письмо помечено как аннулирование, добавляем в список аннулирований");
                                string certNumber = certData.CertNumber;
                                string fio = certData.Fio;
                                DateTime? revokeDate = ExtractRevokeDate(body);
                                revocationList.Add((certNumber, fio, revokeDate, certData.FolderPath));
                                continue;
                            }

                            // Повторный апдейт записи на случай изменений
                            try
                            {
                                var (upd, add) = _db.InsertOrUpdate(certData);
                                if (upd) updatedCount++;
                                if (add) addedCount++;
                            }
                            catch (Exception ex)
                            {
                                Log($"[2-й проход] Ошибка InsertOrUpdate для {certData.CertNumber}: {ex.Message}");
                            }

                            // Если есть ZIP — сохраняем и привязываем к сертификату
                            if (hasZip)
                            {
                                try
                                {
                                    List<string> savedArchives = SaveAttachments(message, certData.Fio, certData.CertNumber);
                                    if (savedArchives != null && savedArchives.Count > 0)
                                    {
                                        foreach (var savedArchive in savedArchives)
                                        {
                                            try
                                            {
                                                if (string.IsNullOrEmpty(savedArchive) || !File.Exists(savedArchive))
                                                {
                                                    Log($"[2-й проход] Пропуск архива (не найден или пустой путь): {savedArchive}");
                                                    continue;
                                                }

                                                int certId = _db.GetCertIdByNumberAndFio(certData.CertNumber, certData.Fio);
                                                if (certId > 0)
                                                {
                                                    bool ok = _db.SaveArchiveToDb(certId, savedArchive);
                                                    if (ok)
                                                    {
                                                        try { File.Delete(savedArchive); } catch { }
                                                        Log($"[2-й проход] Архив сохранён в БД и удалён локально: {savedArchive}");
                                                    }
                                                    else
                                                    {
                                                        Log($"[2-й проход] Ошибка сохранения архива в БД: {savedArchive}");
                                                    }
                                                }
                                                else
                                                {
                                                    Log($"[2-й проход] Сертификат не найден в БД для сохранения архива: {certData.CertNumber} / {certData.Fio}");
                                                }
                                            }
                                            catch (Exception ex)
                                            {
                                                Log($"[2-й проход] Ошибка при обработке архива '{savedArchive}': {ex.Message}");
                                            }
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Log($"[2-й проход] Ошибка при сохранении архива: {ex.Message}");
                                }
                            }

                            results.Add(certData);
                        }
                        catch (Exception ex)
                        {
                            Log($"[2-й проход] Общая ошибка обработки {certData.CertNumber}: {ex.Message}");
                        }
                    }

                    // -----------------------
                    // ТРЕТИЙ ПРОХОД — Применяем аннулирования
                    // -----------------------
                    Log($"=== Третий проход: применение {revocationList.Count} аннулирований ===");

                    foreach (var (certNumber, fio, revokeDate, folderPath) in revocationList)
                    {
                        try
                        {
                            Log($"[3-й проход] Применяем аннулирование: {certNumber} ({fio ?? "ФИО неизвестно"})");
                            bool ok = _db.FindAndMarkAsRevokedByCertNumber(certNumber, fio, folderPath, revokeDate?.ToString("dd.MM.yyyy"));
                            Log(ok ? $"[3-й проход] Успешно: {certNumber}" : $"[3-й проход] Не найден для аннулирования: {certNumber}");
                        }
                        catch (Exception ex)
                        {
                            Log($"[3-й проход] Ошибка при аннулировании {certNumber}: {ex.Message}");
                        }
                    }

                    // Закрываем папку и отключаемся
                    try { folder.Close(); } catch { }
                    client.Disconnect(true);
                }
                catch (Exception exTop)
                {
                    Log($"Ошибка при подключении/обработке почты: {exTop.Message}");
                    try { client.Disconnect(true); } catch { }
                }
            } // using client

            Log($"=== Обработка завершена. Добавлено: {addedCount}, Обновлено: {updatedCount}, Аннулировано: {revocationList.Count} ===");
            return (results, updatedCount, addedCount);
        }




        private bool IsRevokedCertificateMessage(string subject)
        {
            return subject.Contains("аннулирован") ||
                   subject.Contains("прекратил действие");
        }

        private List<string> SaveAttachments(MimeKit.MimeMessage msg, string fio, string certNumber)
        {
            var savedPaths = new List<string>();
            try
            {
                if (!msg.Attachments.Any())
                {
                    Log("В письме нет вложений");
                    return savedPaths;
                }

                Log($"Проверяем вложения письма. Количество: {msg.Attachments.Count()}");

                var safeFio = MakeValidFileName(fio);
                var certFolder = Path.Combine(_attachmentsBasePath, safeFio);

                if (!Directory.Exists(certFolder))
                    Directory.CreateDirectory(certFolder);

                int attachmentCount = 0;
                int zipIndex = 0;

                foreach (var attachment in msg.Attachments)
                {
                    var fileName = attachment.ContentDisposition?.FileName ?? attachment.ContentType.Name;

                    // Если имени нет — сформировать имя-заменитель
                    if (string.IsNullOrEmpty(fileName))
                    {
                        zipIndex++;
                        fileName = $"attachment_{zipIndex}.zip"; // или другим образом
                    }

                    attachmentCount++;
                    Log($"Обрабатываем вложение {attachmentCount}: {fileName}");

                    if (fileName.EndsWith(".zip", StringComparison.OrdinalIgnoreCase))
                    {
                        // чтобы избежать перезаписи при одинаковых именах
                        var uniqueFileName = $"{certNumber}_{zipIndex}_{fileName}";
                        var filePath = Path.Combine(certFolder, uniqueFileName);

                        Log($"Сохраняем ZIP архив: {filePath}");
                        using (var stream = File.Create(filePath))
                        {
                            if (attachment is MimeKit.MessagePart mp)
                                mp.Message.WriteTo(stream);
                            else if (attachment is MimeKit.MimePart part)
                                part.Content.DecodeTo(stream);
                            else
                                Log($"Неизвестный тип вложения: {attachment.GetType().FullName}");
                        }

                        savedPaths.Add(filePath);
                        Log($"Сохранен архив: {filePath}");
                        zipIndex++;
                    }
                    else
                    {
                        Log($"Пропускаем вложение (не ZIP): {fileName}");
                    }
                }

                Log($"Обработано вложений: {attachmentCount}, сохранено архивов: {savedPaths.Count}");
                return savedPaths;
            }
            catch (Exception ex)
            {
                Log($"Ошибка при сохранении вложений: {ex.Message}");
                return savedPaths;
            }
        }


        private string MakeValidFileName(string name)
        {
            var invalidChars = Path.GetInvalidFileNameChars();
            return new string(name.Where(ch => !invalidChars.Contains(ch)).ToArray());
        }

        // Метод для распаковки архива
        public bool ExtractArchive(string archivePath, string fio)
        {
            try
            {
                if (string.IsNullOrEmpty(archivePath) || !File.Exists(archivePath))
                {
                    Log($"Архив не найден: {archivePath}");
                    return false;
                }

                Log($"Распаковываем архив: {archivePath} для {fio}");
                var safeFio = MakeValidFileName(fio);
                var extractPath = Path.Combine(_attachmentsBasePath, safeFio, "extracted");

                if (Directory.Exists(extractPath))
                {
                    Log($"Удаляем существующую папку для распаковки: {extractPath}");
                    Directory.Delete(extractPath, true);
                }

                Directory.CreateDirectory(extractPath);
                Log($"Создана папка для распаковки: {extractPath}");

                // Используем полное имя с указанием пространства имен
                System.IO.Compression.ZipFile.ExtractToDirectory(archivePath, extractPath);
                Log($"Архив распакован: {archivePath} -> {extractPath}");

                // Открываем папку с распакованными файлами
                Log($"Открываем папку с распакованными файлами: {extractPath}");
                System.Diagnostics.Process.Start("explorer.exe", extractPath);

                return true;
            }
            catch (Exception ex)
            {
                Log($"Ошибка при распаковке архива: {ex.Message}");
                return false;
            }
        }

        private string ExtractFio(string body)
        {
            Log("Извлекаем ФИО из тела письма");

            var match = fioRegex.Match(body);
            if (match.Success)
            {
                Log($"ФИО найдено (основной шаблон): {match.Groups["fio"].Value.Trim()}");
                return match.Groups["fio"].Value.Trim();
            }

            match = fioRegexAlt1.Match(body);
            if (match.Success)
            {
                Log($"ФИО найдено (альтернативный шаблон 1): {match.Groups["fio"].Value.Trim()}");
                return match.Groups["fio"].Value.Trim();
            }

            match = fioRegexAlt2.Match(body);
            if (match.Success)
            {
                Log($"ФИО найдено (альтернативный шаблон 2): {match.Groups["fio"].Value.Trim()}");
                return match.Groups["fio"].Value.Trim();
            }

            // Дополнительная попытка найти ФИО в формате "ФИО: Имя Отчество Фамилия"
            var fioPatterns = new[]
            {
                @"ФИО[:\s]+([А-ЯЁ][а-яё]+\s+[А-ЯЁ][а-яё]+\s+[А-ЯЁ][а-яё]+)",
                @"ФИО[:\s]+([А-ЯЁ][а-яё]+\s+[А-ЯЁ][\.]\s*[А-ЯЁ][\.])",
                @"ФИО\s*=\s*([^\.\r\n]+)"
            };

            foreach (var pattern in fioPatterns)
            {
                match = Regex.Match(body, pattern, RegexOptions.IgnoreCase);
                if (match.Success)
                {
                    Log($"ФИО найдено (дополнительный шаблон): {match.Groups[1].Value.Trim()}");
                    return match.Groups[1].Value.Trim();
                }
            }

            Log("ФИО не найдено в теле письма");
            return null;
        }

        private (DateTime start, DateTime end) ExtractDates(string body)
        {
            Log("Извлекаем даты из тела письма");

            var match = datesRegex.Match(body);
            if (match.Success)
            {
                if (TryParseDate(match.Groups["ds"].Value, out DateTime start) &&
                    TryParseDate(match.Groups["de"].Value, out DateTime end))
                {
                    Log($"Даты найдены (основной шаблон): {start} - {end}");
                    return (start, end);
                }
            }

            match = datesRegexAlt1.Match(body);
            if (match.Success)
            {
                if (TryParseDate(match.Groups["ds"].Value, out DateTime start) &&
                    TryParseDate(match.Groups["de"].Value, out DateTime end))
                {
                    Log($"Даты найдены (альтернативный шаблон 1): {start} - {end}");
                    return (start, end);
                }
            }

            match = datesRegexAlt2.Match(body);
            if (match.Success)
            {
                if (TryParseDate(match.Groups["ds"].Value, out DateTime start) &&
                    TryParseDate(match.Groups["de"].Value, out DateTime end))
                {
                    Log($"Даты найдены (альтернативный шаблон 2): {start} - {end}");
                    return (start, end);
                }
            }

            Log("Даты не найдены в теле письма");
            return (DateTime.MinValue, DateTime.MinValue);
        }

        private bool TryParseDate(string dateString, out DateTime result)
        {
            Log($"Парсим дату: {dateString}");

            var formats = new[]
            {
                "dd.MM.yyyy HH:mm:ss",
                "dd.MM.yyyy H:mm:ss",
                "d.MM.yyyy HH:mm:ss",
                "d.MM.yyyy H:mm:ss"
            };

            foreach (var format in formats)
            {
                if (DateTime.TryParseExact(dateString.Trim(), format,
                    System.Globalization.CultureInfo.GetCultureInfo("ru-RU"),
                    System.Globalization.DateTimeStyles.None, out result))
                {
                    Log($"Дата успешно распарсена: {result}");
                    return true;
                }
            }

            Log($"Не удалось распарсить дату: {dateString}");
            result = DateTime.MinValue;
            return false;
        }

        private IMailFolder GetFolderRecursive(ImapClient client, string folderName)
        {
            try
            {
                var folder = client.GetFolder(folderName);
                if (folder != null)
                    return folder;
            }
            catch (FolderNotFoundException)
            {
                Log($"Папка '{folderName}' не найдена, начинаем рекурсивный поиск...");
            }

            var personal = client.GetFolder(client.PersonalNamespaces[0]);
            return FindFolderRecursive(personal, folderName);
        }

        private IMailFolder FindFolderRecursive(IMailFolder parent, string folderName)
        {
            try
            {
                var subfolders = parent.GetSubfolders(false);

                foreach (var folder in subfolders)
                {
                    Log($"Проверяем папку: {folder.FullName}");

                    if (folder.FullName.Equals(folderName, StringComparison.OrdinalIgnoreCase) ||
                        folder.Name.Equals(folderName, StringComparison.OrdinalIgnoreCase))
                    {
                        Log($"Найдена папка: {folder.FullName}");
                        return folder;
                    }

                    try
                    {
                        var foundFolder = FindFolderRecursive(folder, folderName);
                        if (foundFolder != null)
                            return foundFolder;
                    }
                    catch (Exception ex)
                    {
                        Log($"Ошибка при поиске в папке {folder.Name}: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                Log($"Ошибка при получении подпапок для {parent.Name}: {ex.Message}");
            }

            return null;
        }

        private void ProcessRevokedCertificate(string subject, string body, string folderPath, Action<string> addToMiniLog)
        {
            try
            {
                Log("Обработка письма об аннулировании сертификата");

                var certNumber = ExtractCertNumber(subject);
                if (string.IsNullOrWhiteSpace(certNumber))
                {
                    Log("Не удалось извлечь номер сертификата из темы");
                    return;
                }

                var fio = ExtractFio(body);
                if (string.IsNullOrWhiteSpace(fio))
                {
                    Log("Не удалось извлечь ФИО, продолжаем только с номером сертификата");
                    fio = null;
                }

                // ← НОВОЕ: извлекаем дату аннулирования
                var revokeDate = ExtractRevokeDate(body);
                string revokeDateShort = revokeDate?.ToString("dd.MM.yyyy") ?? null;

                Log($"Аннулированный сертификат: № {certNumber}, ФИО: {fio}, Дата отзыва: {revokeDateShort}");

                bool found = _db.FindAndMarkAsRevokedByCertNumber(certNumber, fio, folderPath, revokeDateShort);

                if (found)
                {
                    Log($"Сертификат № {certNumber} успешно помечен как аннулированный");
                    addToMiniLog?.Invoke($"Аннулирован: {fio ?? certNumber} ({revokeDateShort})");
                }
                else
                {
                    Log($"Сертификат № {certNumber} НЕ найден в БД");
                    addToMiniLog?.Invoke($"Аннулирован (не найден в БД): {fio ?? certNumber}");
                }
            }
            catch (Exception ex)
            {
                Log($"Ошибка обработки аннулированного сертификата: {ex.Message}");
            }
        }

        private string ExtractCertNumberFromRevokedSubject(string subject)
        {
            try
            {
                // Паттерн для писем об аннулировании: "Сертификат № 00B675FC41B06766DEF8E20651F0F36547 аннулирован"
                var pattern = @"Сертификат №\s*(?<number>[0-9A-F]+)\s*аннулирован";
                var match = Regex.Match(subject, pattern, RegexOptions.IgnoreCase);

                if (match.Success)
                {
                    return match.Groups["number"].Value.Trim();
                }

                // Альтернативный паттерн
                pattern = @"Сертификат №\s*(?<number>[0-9A-F]+)\s*прекратил действие";
                match = Regex.Match(subject, pattern, RegexOptions.IgnoreCase);

                if (match.Success)
                {
                    return match.Groups["number"].Value.Trim();
                }

                return "Неизвестно";
            }
            catch (Exception ex)
            {
                Log($"Ошибка извлечения номера сертификата из темы аннулирования: {ex.Message}");
                return "Неизвестно";
            }
        }

        private List<IMailFolder> GetAllSubfoldersRecursive(IMailFolder parent)
        {
            var folders = new List<IMailFolder>();

            try
            {
                var subfolders = parent.GetSubfolders(false);
                foreach (var folder in subfolders)
                {
                    folders.Add(folder);
                    folders.AddRange(GetAllSubfoldersRecursive(folder));
                }
            }
            catch (Exception ex)
            {
                Log($"Ошибка при получении подпапок из {parent.FullName}: {ex.Message}");
            }

            return folders;
        }

        public (List<CertEntry> processedEntries, int updatedCount, int addedCount) ProcessAllExistingEmails()
        {
            return CheckMail(true);
        }

        private string GetMessageBody(MimeKit.MimeMessage msg)
        {
            var textPart = msg.TextBody;
            if (!string.IsNullOrEmpty(textPart))
                return textPart;

            var htmlPart = msg.HtmlBody;
            if (!string.IsNullOrEmpty(htmlPart))
            {
                return System.Text.RegularExpressions.Regex.Replace(htmlPart, "<.*?>", string.Empty);
            }

            return msg.Body?.ToString() ?? "";
        }

        private string ExtractCertNumber(string subject)
        {
            var match = certNumberRegex.Match(subject);
            string result = match.Success ? match.Groups["number"].Value.Trim() : "Неизвестно";
            Log($"Извлечен номер сертификата: {result}");
            return result;
        }

        public static List<string> GetMailFolders(AppSettings settings)
        {
            var folders = new List<string>();
            LogStatic("Начало загрузки списка папок с почтового сервера");

            // Проверяем настройки
            if (string.IsNullOrEmpty(settings.MailHost))
                throw new Exception("Не указан хост почтового сервера");
            if (string.IsNullOrEmpty(settings.MailLogin))
                throw new Exception("Не указан логин почтового ящика");
            if (string.IsNullOrEmpty(settings.MailPassword))
                throw new Exception("Не указан пароль почтового ящика");
            if (settings.MailPort <= 0)
                throw new Exception("Неверный порт почтового сервера");

            using (var client = new ImapClient())
            {
                client.Timeout = 30 * 1000; // 30 секунд
                client.ServerCertificateValidationCallback = (s, c, h, e) => true;

                try
                {
                    LogStatic($"Подключение к {settings.MailHost}:{settings.MailPort} (SSL: {settings.MailUseSsl})");

                    if (settings.MailUseSsl)
                    {
                        client.Connect(settings.MailHost, settings.MailPort,
                                     MailKit.Security.SecureSocketOptions.SslOnConnect);
                    }
                    else
                    {
                        try
                        {
                            client.Connect(settings.MailHost, settings.MailPort,
                                         MailKit.Security.SecureSocketOptions.StartTlsWhenAvailable);
                            LogStatic("Подключение через StartTLS успешно");
                        }
                        catch (Exception ex)
                        {
                            LogStatic($"StartTLS не поддерживается, пробуем без SSL: {ex.Message}");
                            client.Connect(settings.MailHost, settings.MailPort,
                                         MailKit.Security.SecureSocketOptions.None);
                            LogStatic("Подключение без SSL успешно");
                        }
                    }

                    LogStatic("Подключение к почтовому серверу успешно");

                    LogStatic($"Аутентификация пользователя: {settings.MailLogin}");
                    client.Authenticate(settings.MailLogin, settings.MailPassword);
                    LogStatic("Аутентификация успешна");

                    var personal = client.GetFolder(client.PersonalNamespaces[0]);
                    var allFolders = GetAllFoldersRecursiveStatic(personal);

                    foreach (var folder in allFolders)
                    {
                        folders.Add(folder.FullName);
                    }

                    folders.Sort();
                    client.Disconnect(true);
                    LogStatic("Отключение от почтового сервера");
                }
                catch (Exception ex)
                {
                    LogStatic($"Ошибка при загрузке папок: {ex.Message}");
                    throw new Exception($"Не удалось подключиться к почтовому серверу: {ex.Message}", ex);
                }
            }

            LogStatic($"Загружено папок: {folders.Count}");
            return folders;
        }

        private static List<IMailFolder> GetAllFoldersRecursiveStatic(IMailFolder parent)
        {
            var folders = new List<IMailFolder>();

            try
            {
                var subfolders = parent.GetSubfolders(false);
                folders.AddRange(subfolders);

                foreach (var folder in subfolders)
                {
                    folders.AddRange(GetAllFoldersRecursiveStatic(folder));
                }
            }
            catch (Exception ex)
            {
                LogStatic($"Ошибка при получении папок из {parent.Name}: {ex.Message}");
            }

            return folders;
        }

        private void Log(string message)
        {
            try
            {
                // Один файл на день вместо файла на каждую секунду
                string logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "LOG", DateTime.Now.ToString("yyyy-MM-dd"));
                if (!Directory.Exists(logDirectory))
                    Directory.CreateDirectory(logDirectory);

                // Файл с именем дня
                string logFile = Path.Combine(logDirectory, $"log_{DateTime.Now:yyyy-MM-dd}.log");
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - [ImapWatcher] {message}{Environment.NewLine}";

                File.AppendAllText(logFile, logEntry, System.Text.Encoding.UTF8);

                // Также пишем в мини-лог через переданный делегат
                _addToMiniLog?.Invoke($"[ImapWatcher] {message}");

                System.Diagnostics.Debug.WriteLine($"[ImapWatcher] {message}");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Ошибка записи в лог: {ex.Message}");
            }
        }

        private static void LogStatic(string message)
        {
            try
            {
                string logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "LOG", DateTime.Now.ToString("yyyy-MM-dd"));
                if (!Directory.Exists(logDirectory))
                    Directory.CreateDirectory(logDirectory);

                string logFile = Path.Combine(logDirectory, $"log_{DateTime.Now:yyyy-MM-dd_HH-mm-ss}.log");
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - [ImapWatcher] {message}{Environment.NewLine}";
                File.AppendAllText(logFile, logEntry, System.Text.Encoding.UTF8);

                // Для статических методов не вызываем мини-лог, т.к. нет доступа к экземпляру
                System.Diagnostics.Debug.WriteLine($"[ImapWatcher] {message}");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Ошибка записи в лог: {ex.Message}");
            }
        }

        private void ValidateMailSettings()
        {
            if (string.IsNullOrEmpty(_settings.MailHost))
                throw new Exception("Не указан хост почтового сервера");

            if (string.IsNullOrEmpty(_settings.MailLogin))
                throw new Exception("Не указан логин почтового ящика");

            if (string.IsNullOrEmpty(_settings.MailPassword))
                throw new Exception("Не указан пароль почтового ящика");

            if (_settings.MailPort <= 0)
                throw new Exception("Неверный порт почтового сервера");

            Log("Проверка настроек почты завершена успешно");
        }
    }
}